/*
 * This file contains the entire source of the program digenv, as written by Jonas Modling and Mikael Sj√∂berg as part of Lab 1 of ID2206 at KTH (2014-11-28).
 * The program will attempt to reproduce the behaviour of 
 * 		printenv [| grep ARGS] | sort | less 
 * through usage of the pipe() and exec()-functions.
 * */
#include <stdio.h> //printf
#include <stdlib.h> //exit
#include <unistd.h> //fork, read
#include <sys/wait.h> //wait, duh

#define READ 0
#define WRITE 1

/*
 * CHECK Have good comments
 * CHECK Check return values
 * CHECK Die if phase in pipeline fails
 * CHECK Don't leave child processes
 * CHECK Compile without warnings
 * CHECK Work with/without/with false parameters
 * CHECK Read envvar PAGER to determine what pager to use
 * */

/*
 * The program entry point. It contains a loop to run through printenv, grep, sort. Then the program runs exec(PAGER) to view the results.
 * */
int main(int argc, char *argv[]){
	/* List of commands to be executed. The loop will iterate over these. */
	char* cmds[4] = {"printenv", "grep", "sort", "less"};
	
	/* Numbers to keep track of file descriptors generated by pipe(). */
	int tmp = -1, filedesc[2];
	if(pipe(filedesc)) return -1;
	
	int i;
	for(i = 0; i < 3; i++){

		if(argc == 1) { /* If no arguments are present, don't execute the grep command. */
			if(i == 1) {
				continue;
			}
		}

		/* Run the commands in separate threads, so error management can be done in the parent. */
		int pid = fork();
		switch(pid)
		{
			/* This is the block the child will execute. The child will copy the input and output stored in the pipe created by the parent process and close both the reading end, writing end, and the write end from the last command, called tmp. It will then run whatever program is next in line in cmds[]. */
			case 0:
			{
				if(close(filedesc[READ])) return -1;

				if(i > 0){
					/* Redirect the current programs stdin to read from tmp. */
					int ret1 = dup2(tmp, fileno(stdin));
					if(ret1 == -1) {
						/* Error, clean up and exit. */
						fprintf(stderr, "Call to dup2(input, stdin) failed in child process.\n");
						if(close(tmp)) return -1;
						if(close(filedesc[WRITE])) return -1;
						return -1;
					}
					if(close(tmp)) return -1;
				}

				/* Redirect the current programs stdout to write to the pipe. */
				int ret2 = dup2(filedesc[WRITE], fileno(stdout));
				if(close(filedesc[WRITE])) return -1;
				if(ret2 == -1){
					fprintf(stderr, "Call to dup2(output, stdout) failed in child process.\n");
					return -1;
				}

				if(i != 1){
					execlp(cmds[i], cmds[i], (char*) 0);
				} else {
					argv[0] = "grep";
					execvp(cmds[i], argv);
				}
				return -1;
			}
			case -1:
			{
				fprintf(stderr, "Error in fork()\n");
				return -1;
			}
			/* This is the block the parent process will execute. It will wait for the child to finish, and make sure it exited without errors. It will also create a new pipe, so that the output from one program can become the input to the next. */
			default:
			{
				if(close(filedesc[WRITE])) return -1;
				if(i > 0){
					if(close(tmp)) return -1;
				}

				/* status will contain the status of the child process after it finishes. */
				int status;
				/* pid2 will contain the process ID of the thread which just returned. This will probably be the pid of the only thread we created (as processes are merged before the next call to fork().) */
				int pid2 = wait(&status);
				if(pid == pid2){
					if(status != 0){
						fprintf(stderr, "Child %d returned with status %d\n",pid2,status);
						if(close(filedesc[READ])) return -1;
						return -1;
					}
					tmp = filedesc[READ];

					if(pipe(filedesc)) return -1;
				} else {
					fprintf(stderr, "Wrong child returned, what the fuck? Expected %d, found %d.\n", pid, pid2);
				}
			}
		}
	}
	if(close(filedesc[0])) return -1;
	if(close(filedesc[1])) return -1;

	/* Redirect the current programs stdin to read from tmp. */
	int ret1 = dup2(tmp, fileno(stdin)); 
	if(close(tmp)) return -1;
	if(ret1 == -1){
		fprintf(stderr, "Call to dup2(input, stdin) failed in parent process.\n");
		return -1;
	}

	/* Read env var PAGER and use that program if possible. Else use less as default. If less fails, use more. If more fails, return error. */
	char* pager = getenv("PAGER");
	if(pager != NULL){
		cmds[3] = pager;
	}

	execlp(cmds[3], cmds[3], (char*) 0);
	execlp("more", "more", (char*) 0);
	
	return -1;
}

/*
//to print 128 chars from filedesc 'tmp'
char buf[128];
int i = 0;
while(i < 128){
	buf[i++] = 0;
}
int ret2 = read(tmp, buf, 128);
fprintf(stderr, "tmp: %s\n", buf);
*/
